/*
 * Copyright (C) 2013 CN-LAB.  All rights reserved.
 * demo_thread.c
 * Original Author: linfushou@gmail.com, 2013-08-23
 * 多线程程序示例
 * 说明: 
 * 1. 多个线程同时被操作系统调度
 * 2. 创建和销毁线程需要消耗系统资源，某些环境可采用线程池方式来解决问题
 * 3. 多线程开发需考虑共享资源访问保护
 * History
 */

#include <stdio.h>
#include <pthread.h>
#include "demo_thread.h"

#define gettid() syscall(__NR_gettid)

/* 新线程执行函数 */
void demo_proc_newthd(void)
{
    int i;
    
    /*
     * difference between gettid() and the pthread_self() is:
     * 1.)POSIX thread IDs are assigned and maintained by the threading implementation. 
     * The thread ID returned by gettid() is a number (similar to a process ID) that is 
     * assigned by the kernel.
     * 2.)ID generated by the pthread_self() can be used after the completion of the \
     * thread but  the ID genereated by the kernel can't be used even after the 
     * completion of the thread..
     * 即gettid()是内核分配的跟PID类似的ID，pthread_self是POSIX thread分配的
     * POSIX thread ID可以供线程函数使用，如pthread_join(tid, NULL)
     */
    printf("New thread, kernel thread ID = %d.\n", gettid());
    printf("New thread, POSIX thread ID = %lu.\n", pthread_self());
    for(i = 0; i < DEMO_LOOP_CNT; i++) {
        sleep(DEMO_SLEEP_TIME);
        printf("This is a pthread.\n");
    }
}

/* 程序入口 */
int main(void)
{
    pthread_t tid;
    int i, ret;

    printf("PID = %d.\n", getpid());
    /* 创建一个新线程 */
    ret = pthread_create(&tid, NULL, (void *)demo_proc_newthd, NULL);
    if(ret != 0){
        printf("Create pthread error!\n");
        return -1;
    }

    /* 通过验证可发现主线程ID和进程PID相等 */
    printf("Main thread, tid = %d.\n", gettid());
    printf("New thread, POSIX thread ID = %lu.\n", tid);
    for(i = 0; i < DEMO_LOOP_CNT; i++) {
        sleep(DEMO_SLEEP_TIME);
        printf("This is the main process.\n");
    }

    /* 以阻塞的方式等待thread指定的线程结束，如果不调用join，那主线程退出时子线程可能未运行完 */
    pthread_join(tid, NULL);
    printf("Exit of program.\n");

    return (0);
}



